/*****************************************************************************
 * vesper - doommake build script
 * (mostly generated by doommake itself, so thanks to MTrop for all o' dis)
 * (c) matt tropiano & xaser acheron 2021
 *     MIT License
 ****************************************************************************/

#include "scripts/doommake-lib.script"
#include "scripts/doommake-init.script"

/* ------------------------------------------------------------------------ */

/**
 * Cleans the build directory found in the properties.
 */
function doClean() {
	initBuild();
	return cleandir(getBuildDirectory());
}


/* ------------------------------------------------------------------------ */

#define SRC_DECOHACK_DIR                 "/decohack"
#define SRC_DECOHACK_ROOT_MAIN           "main"
#define SRC_DECOHACK_ROOT_EXT_DEATHMATCH "ext-deathmatch"

#define IN_DECOHACK_EXTENSION            ".dh"
#define OUT_DECOHACK_PREFIX              "dehsrc-"
#define OUT_DECOHACK_EXTENSION           ".dh"
#define OUT_DEHACKED_PREFIX              "dehacked-"
#define OUT_DEHACKED_EXTENSION           ".deh"

/**
 * Return the output patch file name.
 */
function getVesperPatchFile(rootName) {
	return OUT_DEHACKED_PREFIX + rootName + OUT_DEHACKED_EXTENSION;
}

/**
 * Return the output patch source file name.
 */
function getVesperPatchSourceOutputFile(rootName) {
	return OUT_DECOHACK_PREFIX + rootName + OUT_DECOHACK_EXTENSION;
}

/**
 * Return DECOHack root for the specified root name.
 */
function getVesperDECOHackRoot(rootName) {
	return rootName + IN_DECOHACK_EXTENSION;
}

/**
 * Calls DECOHack.
 * Creates patch from the specified root file.
 */
check function doPatch(budget, sourceDir, rootName) {
	outFile = getBuildDirectory() + "/" + getVesperPatchFile(rootName);
	outSourceFile = getBuildDirectory() + "/" + getVesperPatchSourceOutputFile(rootName);

	decohack(
		file(sourceDir + "/" + getVesperDECOHackRoot(rootName)),
		file(outFile),
		budget,
		file(outSourceFile)
	);
}

/**
 * Creates DEH patches. Word.
 */
check function doPatches(budget) {
	initBuild();

	sourceDir = getSourceDirectory() + SRC_DECOHACK_DIR;
	verifydirs(sourceDir);

	// [XA] TODO: make this work again :P
	if (checkFileExistenceAndBuildStatuses(outFile)) {
		hash = directoryHasChanged(sourceDir);
		if (hash === null) {
			println("[Skipped] DECOHack directory (" + sourceDir + ") up to date.");
			return;
		}
	} else {
		hash = directoryHasChanged(sourceDir);
	}

	println("Compiling patches...");

	doPatch(budget, sourceDir, SRC_DECOHACK_ROOT_MAIN);
	doPatch(budget, sourceDir, SRC_DECOHACK_ROOT_EXT_DEATHMATCH);
	
	storeDirectoryChanged(sourceDir, hash);
	setBuilt("dehacked");
}

/* ------------------------------------------------------------------------ */

#define SRC_DIR_ASSETS     "src/assets" 
#define MERGESCRIPT_ASSETS "scripts/merge-assets.txt"

/**
 * Cleans up the created asset WAD.
 */
check function cleanUpAssetWAD(wadpath) {
	wf = wadfile(wadpath);
	
	// Remove the sprite namespace if empty.
	sx = wadentryindex(wf, "SS_START");
	sy = wadentryindex(wf, "SS_END");
	if (sx !== null && (sy - sx === 1)) {
		wf->waddelete(wf->wadentryindex("SS_START"));
		wf->waddelete(wf->wadentryindex("SS_END"));
	}
	
	close(wf);
}

/**
 * Calls the merge script for merging maps.
 * Creates assets WAD.
 */
check function doAssets() {
	
	initBuild();
	verifydirs(SRC_DIR_ASSETS + "/_global");
	verifydirs(SRC_DIR_ASSETS + "/graphics");
	verifydirs(SRC_DIR_ASSETS + "/music");
	verifydirs(SRC_DIR_ASSETS + "/sounds");
	verifydirs(SRC_DIR_ASSETS + "/sprites");
	
	wadmerge(file(MERGESCRIPT_ASSETS), [
		getBuildDirectory(),
		getAssetsWAD()
	]);
	
	cleanUpAssetWAD(getBuildDirectory() + "/" + getAssetsWAD());
}


/* ------------------------------------------------------------------------ */

#define PROP_RUN_EXE            "doommake.run.exe"
#define PROP_RUN_EXE_WORK       "doommake.run.exe.workdir"
#define PROP_RUN_SWITCH_IWAD    "doommake.run.switch.iwad"
#define DEFAULT_RUN_SWITCH_IWAD "-iwad"
#define PROP_RUN_SWITCH_FILE    "doommake.run.switch.file"
#define DEFAULT_RUN_SWITCH_FILE "-file"
#define PROP_RUN_SWITCH_DEH     "doommake.run.switch.deh"
#define DEFAULT_RUN_SWITCH_DEH  "-deh"
#define PROP_RUN_ARGS           "doommake.run.args"

/**
 * Calls a port to run this project.
 * portType: If specified, then this looks for the properties that end with ".porttype".
 * wadList: List of WAD files to add.
 * dehFile: DEH file to add.
 */
check function doRun(portType, wadList, dehFile) {

	portType = empty(portType) ? "" : "." + portType;

	exepath =    prop(PROP_RUN_EXE + portType);
	exeworkdir = prop(PROP_RUN_EXE_WORK + portType) ?: fileparent(exepath);
	iwadSwitch = prop(PROP_RUN_SWITCH_IWAD + portType, DEFAULT_RUN_SWITCH_IWAD);
	fileSwitch = prop(PROP_RUN_SWITCH_FILE + portType, DEFAULT_RUN_SWITCH_FILE);
	dehSwitch =  prop(PROP_RUN_SWITCH_DEH + portType, DEFAULT_RUN_SWITCH_DEH);
	miscArgs =   prop(PROP_RUN_ARGS + portType);
	
	if (empty(exepath))
		return error("NoEXE", "Executable not specified. Requires a property to be set: " + PROP_RUN_EXE + portType);
	
	if (!fileexists(exepath))
		return error("NoEXE", "Executable could not be found: " + exepath);
	if (!fileexists(exeworkdir))
		return error("NoEXE", "Working directory for executable not found: " + exeworkdir);

	if (empty(iwadSwitch))
		return error("RunError", "IWAD switch not specified. Requires a property to be set: " + PROP_RUN_SWITCH_IWAD + portType);
	if (empty(fileSwitch))
		return error("RunError", "FILE switch not specified. Requires a property to be set: " + PROP_RUN_SWITCH_FILE + portType);
	if (empty(dehSwitch))
		return error("RunError", "DEH switch not specified. Requires a property to be set: " + PROP_RUN_SWITCH_DEH + portType);

	arguments = [];

	iwadPath = getIwad();
	if (empty(iwadPath))
		return error("NoIWAD", "An IWAD for this project was not set in properties: " + PROP_IWADPATH);

	arguments->listadd(iwadSwitch);
	arguments->listadd(iwadPath->filecanonpath());

	if (!empty(wadList)) {
		arguments->listadd(fileSwitch);
		each (w : wadList)
			arguments->listadd(w->filecanonpath());
	}

	if (!empty(dehFile)) {
		arguments->listadd(dehSwitch);
		arguments->listadd(dehFile->filecanonpath());
	}

	if (!empty(miscArgs)) {
		each (a : strsplit(miscArgs, " "))
			arguments->listadd(a);
	}

	return execresult(exec(
		exepath, arguments, envvars(), exeworkdir, stdout(), stderr(), stdin()
	));
}


/* ------------------------------------------------------------------------ */

#define MERGESCRIPT_RELEASE "scripts/merge-release.txt"
#define MERGESCRIPT_EXTENSION "scripts/merge-extension.txt"
#define SRC_WADINFO "src/wadinfo.txt"

/**
 * Initializes the build directory.
 */
function initDist() {
	return verifydirs(getDistDirectory());
}

/**
 * Copies the WAD info to the build directory as its TXT file.
 * Throws error if unsuccessful.
 */
function copyProjectTXT(destfile) {
	srcfile = file(SRC_WADINFO);
	println("Copying " + srcfile + " to " + destfile + "...");
	return copyfile(srcfile, destfile, true);
}

/**
 * Builds every component for the project release.
 */
check function doAll() {
	initBuild();
	doPatches(false);
	doAssets();
}

/**
 * Call wadmerge and build release wad
 */
function mergeRelease(mergescript, wadName, patchRoot) {
	wadmerge(file(mergescript), [
		getBuildDirectory()
		,wadName
		,getVesperPatchFile(patchRoot)
		,getVesperPatchSourceOutputFile(patchRoot)
		,getAssetsWAD()
	]);
}

/**
 * Return the project WAD file name.
 */
function getVesperExtensionWAD(patchRoot) {
	return getProjectName() + "-" + patchRoot + ".wad"; 
}

/**
 * Merges all components into the project file and creates the distributable.
 */
check function doRelease() {
	mergeRelease(MERGESCRIPT_RELEASE, getProjectWad(), SRC_DECOHACK_ROOT_MAIN);
	mergeRelease(MERGESCRIPT_EXTENSION, getVesperExtensionWAD(SRC_DECOHACK_ROOT_EXT_DEATHMATCH), SRC_DECOHACK_ROOT_EXT_DEATHMATCH);

	// Assemble project archive.
	initDist();
	copyProjectTXT(getBuildDirectory() + "/" + getProjectTXT());
	copyProjectTXT(getDistDirectory() + "/" + getProjectTXT());
	zipProject([
		getBuildDirectory() + "/" + getProjectWAD(), 
		getBuildDirectory() + "/" + getProjectTXT()
	]);
	
	println("Done!");
}


/****************************************************************************
 * TARGET: init
 ****************************************************************************
 * Initializes this project.
 * doommake init
 ****************************************************************************/
check entry init(args) {
	doInit(args);
}


/****************************************************************************
 * TARGET: clean
 ****************************************************************************
 * Cleans the build directory.
 * doommake clean
 ****************************************************************************/
check entry clean(args) {
	doClean();
}


/*****************************************************************************
 * TARGET: patch
 *****************************************************************************
 * Compiles the DeHackEd patches (and shows the budget).
 * doommake patch
 ****************************************************************************/
check entry patch(args) {
	doPatches(true);
}

/*****************************************************************************
 * TARGET: assets
 *****************************************************************************
 * Merges the assets WAD.
 * doommake assets
 ****************************************************************************/
check entry assets(args) {
	doAssets();
}


/*****************************************************************************
 * TARGET: run
 *****************************************************************************
 * Runs this project.
 * doommake run
 ****************************************************************************/
check entry run(args) {

	wadList = [
		getBuildDirectory() + "/" + getProjectWAD()
	];
	
	// Set DEH file here, if any.
	dehFile = null;

	return doRun(args[0], wadList, dehFile);
}

/****************************************************************************
 * TARGET: all
 ****************************************************************************
 * Builds all parts of the project. 
 * doommake all
 ****************************************************************************/
check entry all(args) {
	doAll();
}


/****************************************************************************
 * TARGET: release
 ****************************************************************************
 * Creates a release and distribution.
 * doommake release
 ****************************************************************************/
check entry release(args) {
	doRelease();
}


/****************************************************************************
 * TARGET: make
 ****************************************************************************
 * Default make target.
 * doommake
 ****************************************************************************/
check entry make(args) {
	doInit();
	doAll();
	doRelease();
}
